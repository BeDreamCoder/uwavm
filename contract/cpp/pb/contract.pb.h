// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contract.proto

#ifndef PROTOBUF_INCLUDED_contract_2eproto
#define PROTOBUF_INCLUDED_contract_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_contract_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_contract_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace contract {
class ArgPair;
class ArgPairDefaultTypeInternal;
extern ArgPairDefaultTypeInternal _ArgPair_default_instance_;
class CallArgs;
class CallArgsDefaultTypeInternal;
extern CallArgsDefaultTypeInternal _CallArgs_default_instance_;
class ContractCallRequest;
class ContractCallRequestDefaultTypeInternal;
extern ContractCallRequestDefaultTypeInternal _ContractCallRequest_default_instance_;
class ContractCallResponse;
class ContractCallResponseDefaultTypeInternal;
extern ContractCallResponseDefaultTypeInternal _ContractCallResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetCallArgsRequest;
class GetCallArgsRequestDefaultTypeInternal;
extern GetCallArgsRequestDefaultTypeInternal _GetCallArgsRequest_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class PutRequest;
class PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
class PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SetOutputRequest;
class SetOutputRequestDefaultTypeInternal;
extern SetOutputRequestDefaultTypeInternal _SetOutputRequest_default_instance_;
class SetOutputResponse;
class SetOutputResponseDefaultTypeInternal;
extern SetOutputResponseDefaultTypeInternal _SetOutputResponse_default_instance_;
class SyscallHeader;
class SyscallHeaderDefaultTypeInternal;
extern SyscallHeaderDefaultTypeInternal _SyscallHeader_default_instance_;
class TransferRequest;
class TransferRequestDefaultTypeInternal;
extern TransferRequestDefaultTypeInternal _TransferRequest_default_instance_;
class TransferResponse;
class TransferResponseDefaultTypeInternal;
extern TransferResponseDefaultTypeInternal _TransferResponse_default_instance_;
}  // namespace contract
namespace google {
namespace protobuf {
template<> ::contract::ArgPair* Arena::CreateMaybeMessage<::contract::ArgPair>(Arena*);
template<> ::contract::CallArgs* Arena::CreateMaybeMessage<::contract::CallArgs>(Arena*);
template<> ::contract::ContractCallRequest* Arena::CreateMaybeMessage<::contract::ContractCallRequest>(Arena*);
template<> ::contract::ContractCallResponse* Arena::CreateMaybeMessage<::contract::ContractCallResponse>(Arena*);
template<> ::contract::DeleteRequest* Arena::CreateMaybeMessage<::contract::DeleteRequest>(Arena*);
template<> ::contract::DeleteResponse* Arena::CreateMaybeMessage<::contract::DeleteResponse>(Arena*);
template<> ::contract::GetCallArgsRequest* Arena::CreateMaybeMessage<::contract::GetCallArgsRequest>(Arena*);
template<> ::contract::GetRequest* Arena::CreateMaybeMessage<::contract::GetRequest>(Arena*);
template<> ::contract::GetResponse* Arena::CreateMaybeMessage<::contract::GetResponse>(Arena*);
template<> ::contract::PutRequest* Arena::CreateMaybeMessage<::contract::PutRequest>(Arena*);
template<> ::contract::PutResponse* Arena::CreateMaybeMessage<::contract::PutResponse>(Arena*);
template<> ::contract::Response* Arena::CreateMaybeMessage<::contract::Response>(Arena*);
template<> ::contract::SetOutputRequest* Arena::CreateMaybeMessage<::contract::SetOutputRequest>(Arena*);
template<> ::contract::SetOutputResponse* Arena::CreateMaybeMessage<::contract::SetOutputResponse>(Arena*);
template<> ::contract::SyscallHeader* Arena::CreateMaybeMessage<::contract::SyscallHeader>(Arena*);
template<> ::contract::TransferRequest* Arena::CreateMaybeMessage<::contract::TransferRequest>(Arena*);
template<> ::contract::TransferResponse* Arena::CreateMaybeMessage<::contract::TransferResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace contract {

// ===================================================================

class ArgPair :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.ArgPair) */ {
 public:
  ArgPair();
  virtual ~ArgPair();

  ArgPair(const ArgPair& from);

  inline ArgPair& operator=(const ArgPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArgPair(ArgPair&& from) noexcept
    : ArgPair() {
    *this = ::std::move(from);
  }

  inline ArgPair& operator=(ArgPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ArgPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArgPair* internal_default_instance() {
    return reinterpret_cast<const ArgPair*>(
               &_ArgPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ArgPair* other);
  friend void swap(ArgPair& a, ArgPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArgPair* New() const final {
    return CreateMaybeMessage<ArgPair>(nullptr);
  }

  ArgPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArgPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ArgPair& from);
  void MergeFrom(const ArgPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArgPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:contract.ArgPair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class CallArgs :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.CallArgs) */ {
 public:
  CallArgs();
  virtual ~CallArgs();

  CallArgs(const CallArgs& from);

  inline CallArgs& operator=(const CallArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CallArgs(CallArgs&& from) noexcept
    : CallArgs() {
    *this = ::std::move(from);
  }

  inline CallArgs& operator=(CallArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CallArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CallArgs* internal_default_instance() {
    return reinterpret_cast<const CallArgs*>(
               &_CallArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CallArgs* other);
  friend void swap(CallArgs& a, CallArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CallArgs* New() const final {
    return CreateMaybeMessage<CallArgs>(nullptr);
  }

  CallArgs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CallArgs>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CallArgs& from);
  void MergeFrom(const CallArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .contract.ArgPair args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::contract::ArgPair* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >*
      mutable_args();
  const ::contract::ArgPair& args(int index) const;
  ::contract::ArgPair* add_args();
  const ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >&
      args() const;

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // string caller = 3;
  void clear_caller();
  static const int kCallerFieldNumber = 3;
  const ::std::string& caller() const;
  void set_caller(const ::std::string& value);
  #if LANG_CXX11
  void set_caller(::std::string&& value);
  #endif
  void set_caller(const char* value);
  void set_caller(const char* value, size_t size);
  ::std::string* mutable_caller();
  ::std::string* release_caller();
  void set_allocated_caller(::std::string* caller);

  // @@protoc_insertion_point(class_scope:contract.CallArgs)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::contract::ArgPair > args_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr caller_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SyscallHeader :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.SyscallHeader) */ {
 public:
  SyscallHeader();
  virtual ~SyscallHeader();

  SyscallHeader(const SyscallHeader& from);

  inline SyscallHeader& operator=(const SyscallHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyscallHeader(SyscallHeader&& from) noexcept
    : SyscallHeader() {
    *this = ::std::move(from);
  }

  inline SyscallHeader& operator=(SyscallHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SyscallHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyscallHeader* internal_default_instance() {
    return reinterpret_cast<const SyscallHeader*>(
               &_SyscallHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SyscallHeader* other);
  friend void swap(SyscallHeader& a, SyscallHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyscallHeader* New() const final {
    return CreateMaybeMessage<SyscallHeader>(nullptr);
  }

  SyscallHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyscallHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SyscallHeader& from);
  void MergeFrom(const SyscallHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SyscallHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 ctxid = 1;
  void clear_ctxid();
  static const int kCtxidFieldNumber = 1;
  ::google::protobuf::int64 ctxid() const;
  void set_ctxid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:contract.SyscallHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 ctxid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class PutRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.PutRequest) */ {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PutRequest* other);
  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutRequest* New() const final {
    return CreateMaybeMessage<PutRequest>(nullptr);
  }

  PutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.PutRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class PutResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.PutResponse) */ {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PutResponse* other);
  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutResponse* New() const final {
    return CreateMaybeMessage<PutResponse>(nullptr);
  }

  PutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:contract.PutResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.GetRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetResponse* other);
  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:contract.GetResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(nullptr);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.DeleteRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(nullptr);
  }

  DeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:contract.DeleteResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TransferRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.TransferRequest) */ {
 public:
  TransferRequest();
  virtual ~TransferRequest();

  TransferRequest(const TransferRequest& from);

  inline TransferRequest& operator=(const TransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferRequest(TransferRequest&& from) noexcept
    : TransferRequest() {
    *this = ::std::move(from);
  }

  inline TransferRequest& operator=(TransferRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TransferRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferRequest* internal_default_instance() {
    return reinterpret_cast<const TransferRequest*>(
               &_TransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TransferRequest* other);
  friend void swap(TransferRequest& a, TransferRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferRequest* New() const final {
    return CreateMaybeMessage<TransferRequest>(nullptr);
  }

  TransferRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TransferRequest& from);
  void MergeFrom(const TransferRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransferRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string amount = 4;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.TransferRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TransferResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.TransferResponse) */ {
 public:
  TransferResponse();
  virtual ~TransferResponse();

  TransferResponse(const TransferResponse& from);

  inline TransferResponse& operator=(const TransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferResponse(TransferResponse&& from) noexcept
    : TransferResponse() {
    *this = ::std::move(from);
  }

  inline TransferResponse& operator=(TransferResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TransferResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferResponse* internal_default_instance() {
    return reinterpret_cast<const TransferResponse*>(
               &_TransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(TransferResponse* other);
  friend void swap(TransferResponse& a, TransferResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferResponse* New() const final {
    return CreateMaybeMessage<TransferResponse>(nullptr);
  }

  TransferResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TransferResponse& from);
  void MergeFrom(const TransferResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransferResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:contract.TransferResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class ContractCallRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.ContractCallRequest) */ {
 public:
  ContractCallRequest();
  virtual ~ContractCallRequest();

  ContractCallRequest(const ContractCallRequest& from);

  inline ContractCallRequest& operator=(const ContractCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractCallRequest(ContractCallRequest&& from) noexcept
    : ContractCallRequest() {
    *this = ::std::move(from);
  }

  inline ContractCallRequest& operator=(ContractCallRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ContractCallRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractCallRequest* internal_default_instance() {
    return reinterpret_cast<const ContractCallRequest*>(
               &_ContractCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ContractCallRequest* other);
  friend void swap(ContractCallRequest& a, ContractCallRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractCallRequest* New() const final {
    return CreateMaybeMessage<ContractCallRequest>(nullptr);
  }

  ContractCallRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContractCallRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ContractCallRequest& from);
  void MergeFrom(const ContractCallRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContractCallRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .contract.ArgPair args = 5;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 5;
  ::contract::ArgPair* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >*
      mutable_args();
  const ::contract::ArgPair& args(int index) const;
  ::contract::ArgPair* add_args();
  const ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >&
      args() const;

  // string module = 2;
  void clear_module();
  static const int kModuleFieldNumber = 2;
  const ::std::string& module() const;
  void set_module(const ::std::string& value);
  #if LANG_CXX11
  void set_module(::std::string&& value);
  #endif
  void set_module(const char* value);
  void set_module(const char* value, size_t size);
  ::std::string* mutable_module();
  ::std::string* release_module();
  void set_allocated_module(::std::string* module);

  // string contract = 3;
  void clear_contract();
  static const int kContractFieldNumber = 3;
  const ::std::string& contract() const;
  void set_contract(const ::std::string& value);
  #if LANG_CXX11
  void set_contract(::std::string&& value);
  #endif
  void set_contract(const char* value);
  void set_contract(const char* value, size_t size);
  ::std::string* mutable_contract();
  ::std::string* release_contract();
  void set_allocated_contract(::std::string* contract);

  // string method = 4;
  void clear_method();
  static const int kMethodFieldNumber = 4;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.ContractCallRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::contract::ArgPair > args_;
  ::google::protobuf::internal::ArenaStringPtr module_;
  ::google::protobuf::internal::ArenaStringPtr contract_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class ContractCallResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.ContractCallResponse) */ {
 public:
  ContractCallResponse();
  virtual ~ContractCallResponse();

  ContractCallResponse(const ContractCallResponse& from);

  inline ContractCallResponse& operator=(const ContractCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractCallResponse(ContractCallResponse&& from) noexcept
    : ContractCallResponse() {
    *this = ::std::move(from);
  }

  inline ContractCallResponse& operator=(ContractCallResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ContractCallResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractCallResponse* internal_default_instance() {
    return reinterpret_cast<const ContractCallResponse*>(
               &_ContractCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ContractCallResponse* other);
  friend void swap(ContractCallResponse& a, ContractCallResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractCallResponse* New() const final {
    return CreateMaybeMessage<ContractCallResponse>(nullptr);
  }

  ContractCallResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContractCallResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ContractCallResponse& from);
  void MergeFrom(const ContractCallResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContractCallResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .contract.Response response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  const ::contract::Response& response() const;
  ::contract::Response* release_response();
  ::contract::Response* mutable_response();
  void set_allocated_response(::contract::Response* response);

  // @@protoc_insertion_point(class_scope:contract.ContractCallResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::contract::Response* response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:contract.Response)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SetOutputRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.SetOutputRequest) */ {
 public:
  SetOutputRequest();
  virtual ~SetOutputRequest();

  SetOutputRequest(const SetOutputRequest& from);

  inline SetOutputRequest& operator=(const SetOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetOutputRequest(SetOutputRequest&& from) noexcept
    : SetOutputRequest() {
    *this = ::std::move(from);
  }

  inline SetOutputRequest& operator=(SetOutputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetOutputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetOutputRequest* internal_default_instance() {
    return reinterpret_cast<const SetOutputRequest*>(
               &_SetOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SetOutputRequest* other);
  friend void swap(SetOutputRequest& a, SetOutputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetOutputRequest* New() const final {
    return CreateMaybeMessage<SetOutputRequest>(nullptr);
  }

  SetOutputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetOutputRequest& from);
  void MergeFrom(const SetOutputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetOutputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // .contract.Response response = 2;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 2;
  const ::contract::Response& response() const;
  ::contract::Response* release_response();
  ::contract::Response* mutable_response();
  void set_allocated_response(::contract::Response* response);

  // @@protoc_insertion_point(class_scope:contract.SetOutputRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::contract::SyscallHeader* header_;
  ::contract::Response* response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SetOutputResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.SetOutputResponse) */ {
 public:
  SetOutputResponse();
  virtual ~SetOutputResponse();

  SetOutputResponse(const SetOutputResponse& from);

  inline SetOutputResponse& operator=(const SetOutputResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetOutputResponse(SetOutputResponse&& from) noexcept
    : SetOutputResponse() {
    *this = ::std::move(from);
  }

  inline SetOutputResponse& operator=(SetOutputResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetOutputResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetOutputResponse* internal_default_instance() {
    return reinterpret_cast<const SetOutputResponse*>(
               &_SetOutputResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SetOutputResponse* other);
  friend void swap(SetOutputResponse& a, SetOutputResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetOutputResponse* New() const final {
    return CreateMaybeMessage<SetOutputResponse>(nullptr);
  }

  SetOutputResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetOutputResponse& from);
  void MergeFrom(const SetOutputResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetOutputResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:contract.SetOutputResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetCallArgsRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:contract.GetCallArgsRequest) */ {
 public:
  GetCallArgsRequest();
  virtual ~GetCallArgsRequest();

  GetCallArgsRequest(const GetCallArgsRequest& from);

  inline GetCallArgsRequest& operator=(const GetCallArgsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetCallArgsRequest(GetCallArgsRequest&& from) noexcept
    : GetCallArgsRequest() {
    *this = ::std::move(from);
  }

  inline GetCallArgsRequest& operator=(GetCallArgsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetCallArgsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCallArgsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCallArgsRequest*>(
               &_GetCallArgsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetCallArgsRequest* other);
  friend void swap(GetCallArgsRequest& a, GetCallArgsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCallArgsRequest* New() const final {
    return CreateMaybeMessage<GetCallArgsRequest>(nullptr);
  }

  GetCallArgsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetCallArgsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetCallArgsRequest& from);
  void MergeFrom(const GetCallArgsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCallArgsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .contract.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::contract::SyscallHeader& header() const;
  ::contract::SyscallHeader* release_header();
  ::contract::SyscallHeader* mutable_header();
  void set_allocated_header(::contract::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:contract.GetCallArgsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::contract::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ArgPair

// string key = 1;
inline void ArgPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArgPair::key() const {
  // @@protoc_insertion_point(field_get:contract.ArgPair.key)
  return key_.GetNoArena();
}
inline void ArgPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.ArgPair.key)
}
#if LANG_CXX11
inline void ArgPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.ArgPair.key)
}
#endif
inline void ArgPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.ArgPair.key)
}
inline void ArgPair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.ArgPair.key)
}
inline ::std::string* ArgPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:contract.ArgPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArgPair::release_key() {
  // @@protoc_insertion_point(field_release:contract.ArgPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArgPair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:contract.ArgPair.key)
}

// bytes value = 2;
inline void ArgPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArgPair::value() const {
  // @@protoc_insertion_point(field_get:contract.ArgPair.value)
  return value_.GetNoArena();
}
inline void ArgPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.ArgPair.value)
}
#if LANG_CXX11
inline void ArgPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.ArgPair.value)
}
#endif
inline void ArgPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.ArgPair.value)
}
inline void ArgPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.ArgPair.value)
}
inline ::std::string* ArgPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:contract.ArgPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArgPair::release_value() {
  // @@protoc_insertion_point(field_release:contract.ArgPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArgPair::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:contract.ArgPair.value)
}

// -------------------------------------------------------------------

// CallArgs

// string method = 1;
inline void CallArgs::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallArgs::method() const {
  // @@protoc_insertion_point(field_get:contract.CallArgs.method)
  return method_.GetNoArena();
}
inline void CallArgs::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.CallArgs.method)
}
#if LANG_CXX11
inline void CallArgs::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.CallArgs.method)
}
#endif
inline void CallArgs::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.CallArgs.method)
}
inline void CallArgs::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.CallArgs.method)
}
inline ::std::string* CallArgs::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:contract.CallArgs.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallArgs::release_method() {
  // @@protoc_insertion_point(field_release:contract.CallArgs.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallArgs::set_allocated_method(::std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:contract.CallArgs.method)
}

// repeated .contract.ArgPair args = 2;
inline int CallArgs::args_size() const {
  return args_.size();
}
inline void CallArgs::clear_args() {
  args_.Clear();
}
inline ::contract::ArgPair* CallArgs::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:contract.CallArgs.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >*
CallArgs::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:contract.CallArgs.args)
  return &args_;
}
inline const ::contract::ArgPair& CallArgs::args(int index) const {
  // @@protoc_insertion_point(field_get:contract.CallArgs.args)
  return args_.Get(index);
}
inline ::contract::ArgPair* CallArgs::add_args() {
  // @@protoc_insertion_point(field_add:contract.CallArgs.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >&
CallArgs::args() const {
  // @@protoc_insertion_point(field_list:contract.CallArgs.args)
  return args_;
}

// string caller = 3;
inline void CallArgs::clear_caller() {
  caller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallArgs::caller() const {
  // @@protoc_insertion_point(field_get:contract.CallArgs.caller)
  return caller_.GetNoArena();
}
inline void CallArgs::set_caller(const ::std::string& value) {
  
  caller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.CallArgs.caller)
}
#if LANG_CXX11
inline void CallArgs::set_caller(::std::string&& value) {
  
  caller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.CallArgs.caller)
}
#endif
inline void CallArgs::set_caller(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  caller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.CallArgs.caller)
}
inline void CallArgs::set_caller(const char* value, size_t size) {
  
  caller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.CallArgs.caller)
}
inline ::std::string* CallArgs::mutable_caller() {
  
  // @@protoc_insertion_point(field_mutable:contract.CallArgs.caller)
  return caller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallArgs::release_caller() {
  // @@protoc_insertion_point(field_release:contract.CallArgs.caller)
  
  return caller_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallArgs::set_allocated_caller(::std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  caller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), caller);
  // @@protoc_insertion_point(field_set_allocated:contract.CallArgs.caller)
}

// -------------------------------------------------------------------

// SyscallHeader

// int64 ctxid = 1;
inline void SyscallHeader::clear_ctxid() {
  ctxid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SyscallHeader::ctxid() const {
  // @@protoc_insertion_point(field_get:contract.SyscallHeader.ctxid)
  return ctxid_;
}
inline void SyscallHeader::set_ctxid(::google::protobuf::int64 value) {
  
  ctxid_ = value;
  // @@protoc_insertion_point(field_set:contract.SyscallHeader.ctxid)
}

// -------------------------------------------------------------------

// PutRequest

// .contract.SyscallHeader header = 1;
inline bool PutRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& PutRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.PutRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* PutRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.PutRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* PutRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.PutRequest.header)
  return header_;
}
inline void PutRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.PutRequest.header)
}

// bytes key = 2;
inline void PutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:contract.PutRequest.key)
  return key_.GetNoArena();
}
inline void PutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.PutRequest.key)
}
#if LANG_CXX11
inline void PutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.PutRequest.key)
}
#endif
inline void PutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.PutRequest.key)
}
inline void PutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.PutRequest.key)
}
inline ::std::string* PutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:contract.PutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:contract.PutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:contract.PutRequest.key)
}

// bytes value = 3;
inline void PutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:contract.PutRequest.value)
  return value_.GetNoArena();
}
inline void PutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.PutRequest.value)
}
#if LANG_CXX11
inline void PutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.PutRequest.value)
}
#endif
inline void PutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.PutRequest.value)
}
inline void PutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.PutRequest.value)
}
inline ::std::string* PutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:contract.PutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:contract.PutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:contract.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// -------------------------------------------------------------------

// GetRequest

// .contract.SyscallHeader header = 1;
inline bool GetRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& GetRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.GetRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* GetRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.GetRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* GetRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.GetRequest.header)
  return header_;
}
inline void GetRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.GetRequest.header)
}

// bytes key = 2;
inline void GetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:contract.GetRequest.key)
  return key_.GetNoArena();
}
inline void GetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.GetRequest.key)
}
#if LANG_CXX11
inline void GetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.GetRequest.key)
}
#endif
inline void GetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.GetRequest.key)
}
inline void GetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.GetRequest.key)
}
inline ::std::string* GetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:contract.GetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:contract.GetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:contract.GetRequest.key)
}

// -------------------------------------------------------------------

// GetResponse

// bytes value = 1;
inline void GetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:contract.GetResponse.value)
  return value_.GetNoArena();
}
inline void GetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.GetResponse.value)
}
#if LANG_CXX11
inline void GetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.GetResponse.value)
}
#endif
inline void GetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.GetResponse.value)
}
inline void GetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.GetResponse.value)
}
inline ::std::string* GetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:contract.GetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:contract.GetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetResponse::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:contract.GetResponse.value)
}

// -------------------------------------------------------------------

// DeleteRequest

// .contract.SyscallHeader header = 1;
inline bool DeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& DeleteRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.DeleteRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* DeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.DeleteRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* DeleteRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.DeleteRequest.header)
  return header_;
}
inline void DeleteRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.DeleteRequest.header)
}

// bytes key = 2;
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:contract.DeleteRequest.key)
  return key_.GetNoArena();
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.DeleteRequest.key)
}
#if LANG_CXX11
inline void DeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.DeleteRequest.key)
}
#endif
inline void DeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:contract.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:contract.DeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:contract.DeleteRequest.key)
}

// -------------------------------------------------------------------

// DeleteResponse

// -------------------------------------------------------------------

// TransferRequest

// .contract.SyscallHeader header = 1;
inline bool TransferRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& TransferRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.TransferRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* TransferRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.TransferRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* TransferRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.TransferRequest.header)
  return header_;
}
inline void TransferRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.TransferRequest.header)
}

// string from = 2;
inline void TransferRequest::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::from() const {
  // @@protoc_insertion_point(field_get:contract.TransferRequest.from)
  return from_.GetNoArena();
}
inline void TransferRequest::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.TransferRequest.from)
}
#if LANG_CXX11
inline void TransferRequest::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.TransferRequest.from)
}
#endif
inline void TransferRequest::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.TransferRequest.from)
}
inline void TransferRequest::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.TransferRequest.from)
}
inline ::std::string* TransferRequest::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:contract.TransferRequest.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_from() {
  // @@protoc_insertion_point(field_release:contract.TransferRequest.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_from(::std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:contract.TransferRequest.from)
}

// string to = 3;
inline void TransferRequest::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::to() const {
  // @@protoc_insertion_point(field_get:contract.TransferRequest.to)
  return to_.GetNoArena();
}
inline void TransferRequest::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.TransferRequest.to)
}
#if LANG_CXX11
inline void TransferRequest::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.TransferRequest.to)
}
#endif
inline void TransferRequest::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.TransferRequest.to)
}
inline void TransferRequest::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.TransferRequest.to)
}
inline ::std::string* TransferRequest::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:contract.TransferRequest.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_to() {
  // @@protoc_insertion_point(field_release:contract.TransferRequest.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_to(::std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:contract.TransferRequest.to)
}

// string amount = 4;
inline void TransferRequest::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::amount() const {
  // @@protoc_insertion_point(field_get:contract.TransferRequest.amount)
  return amount_.GetNoArena();
}
inline void TransferRequest::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.TransferRequest.amount)
}
#if LANG_CXX11
inline void TransferRequest::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.TransferRequest.amount)
}
#endif
inline void TransferRequest::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.TransferRequest.amount)
}
inline void TransferRequest::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.TransferRequest.amount)
}
inline ::std::string* TransferRequest::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:contract.TransferRequest.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_amount() {
  // @@protoc_insertion_point(field_release:contract.TransferRequest.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:contract.TransferRequest.amount)
}

// -------------------------------------------------------------------

// TransferResponse

// -------------------------------------------------------------------

// ContractCallRequest

// .contract.SyscallHeader header = 1;
inline bool ContractCallRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ContractCallRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& ContractCallRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.ContractCallRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* ContractCallRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.ContractCallRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* ContractCallRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.ContractCallRequest.header)
  return header_;
}
inline void ContractCallRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.ContractCallRequest.header)
}

// string module = 2;
inline void ContractCallRequest::clear_module() {
  module_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::module() const {
  // @@protoc_insertion_point(field_get:contract.ContractCallRequest.module)
  return module_.GetNoArena();
}
inline void ContractCallRequest::set_module(const ::std::string& value) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.ContractCallRequest.module)
}
#if LANG_CXX11
inline void ContractCallRequest::set_module(::std::string&& value) {
  
  module_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.ContractCallRequest.module)
}
#endif
inline void ContractCallRequest::set_module(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.ContractCallRequest.module)
}
inline void ContractCallRequest::set_module(const char* value, size_t size) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.ContractCallRequest.module)
}
inline ::std::string* ContractCallRequest::mutable_module() {
  
  // @@protoc_insertion_point(field_mutable:contract.ContractCallRequest.module)
  return module_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_module() {
  // @@protoc_insertion_point(field_release:contract.ContractCallRequest.module)
  
  return module_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_module(::std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  module_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module);
  // @@protoc_insertion_point(field_set_allocated:contract.ContractCallRequest.module)
}

// string contract = 3;
inline void ContractCallRequest::clear_contract() {
  contract_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::contract() const {
  // @@protoc_insertion_point(field_get:contract.ContractCallRequest.contract)
  return contract_.GetNoArena();
}
inline void ContractCallRequest::set_contract(const ::std::string& value) {
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.ContractCallRequest.contract)
}
#if LANG_CXX11
inline void ContractCallRequest::set_contract(::std::string&& value) {
  
  contract_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.ContractCallRequest.contract)
}
#endif
inline void ContractCallRequest::set_contract(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.ContractCallRequest.contract)
}
inline void ContractCallRequest::set_contract(const char* value, size_t size) {
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.ContractCallRequest.contract)
}
inline ::std::string* ContractCallRequest::mutable_contract() {
  
  // @@protoc_insertion_point(field_mutable:contract.ContractCallRequest.contract)
  return contract_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_contract() {
  // @@protoc_insertion_point(field_release:contract.ContractCallRequest.contract)
  
  return contract_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_contract(::std::string* contract) {
  if (contract != nullptr) {
    
  } else {
    
  }
  contract_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract);
  // @@protoc_insertion_point(field_set_allocated:contract.ContractCallRequest.contract)
}

// string method = 4;
inline void ContractCallRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::method() const {
  // @@protoc_insertion_point(field_get:contract.ContractCallRequest.method)
  return method_.GetNoArena();
}
inline void ContractCallRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.ContractCallRequest.method)
}
#if LANG_CXX11
inline void ContractCallRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.ContractCallRequest.method)
}
#endif
inline void ContractCallRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.ContractCallRequest.method)
}
inline void ContractCallRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.ContractCallRequest.method)
}
inline ::std::string* ContractCallRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:contract.ContractCallRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_method() {
  // @@protoc_insertion_point(field_release:contract.ContractCallRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_method(::std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:contract.ContractCallRequest.method)
}

// repeated .contract.ArgPair args = 5;
inline int ContractCallRequest::args_size() const {
  return args_.size();
}
inline void ContractCallRequest::clear_args() {
  args_.Clear();
}
inline ::contract::ArgPair* ContractCallRequest::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:contract.ContractCallRequest.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >*
ContractCallRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:contract.ContractCallRequest.args)
  return &args_;
}
inline const ::contract::ArgPair& ContractCallRequest::args(int index) const {
  // @@protoc_insertion_point(field_get:contract.ContractCallRequest.args)
  return args_.Get(index);
}
inline ::contract::ArgPair* ContractCallRequest::add_args() {
  // @@protoc_insertion_point(field_add:contract.ContractCallRequest.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::contract::ArgPair >&
ContractCallRequest::args() const {
  // @@protoc_insertion_point(field_list:contract.ContractCallRequest.args)
  return args_;
}

// -------------------------------------------------------------------

// ContractCallResponse

// .contract.Response response = 1;
inline bool ContractCallResponse::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline void ContractCallResponse::clear_response() {
  if (GetArenaNoVirtual() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::contract::Response& ContractCallResponse::response() const {
  const ::contract::Response* p = response_;
  // @@protoc_insertion_point(field_get:contract.ContractCallResponse.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::Response*>(
      &::contract::_Response_default_instance_);
}
inline ::contract::Response* ContractCallResponse::release_response() {
  // @@protoc_insertion_point(field_release:contract.ContractCallResponse.response)
  
  ::contract::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::contract::Response* ContractCallResponse::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.ContractCallResponse.response)
  return response_;
}
inline void ContractCallResponse::set_allocated_response(::contract::Response* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:contract.ContractCallResponse.response)
}

// -------------------------------------------------------------------

// Response

// int32 status = 1;
inline void Response::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 Response::status() const {
  // @@protoc_insertion_point(field_get:contract.Response.status)
  return status_;
}
inline void Response::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:contract.Response.status)
}

// string message = 2;
inline void Response::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::message() const {
  // @@protoc_insertion_point(field_get:contract.Response.message)
  return message_.GetNoArena();
}
inline void Response::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.Response.message)
}
#if LANG_CXX11
inline void Response::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.Response.message)
}
#endif
inline void Response::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.Response.message)
}
inline void Response::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.Response.message)
}
inline ::std::string* Response::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:contract.Response.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_message() {
  // @@protoc_insertion_point(field_release:contract.Response.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:contract.Response.message)
}

// bytes body = 3;
inline void Response::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::body() const {
  // @@protoc_insertion_point(field_get:contract.Response.body)
  return body_.GetNoArena();
}
inline void Response::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:contract.Response.body)
}
#if LANG_CXX11
inline void Response::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract.Response.body)
}
#endif
inline void Response::set_body(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract.Response.body)
}
inline void Response::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract.Response.body)
}
inline ::std::string* Response::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:contract.Response.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_body() {
  // @@protoc_insertion_point(field_release:contract.Response.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_body(::std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:contract.Response.body)
}

// -------------------------------------------------------------------

// SetOutputRequest

// .contract.SyscallHeader header = 1;
inline bool SetOutputRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void SetOutputRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& SetOutputRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.SetOutputRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* SetOutputRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.SetOutputRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* SetOutputRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.SetOutputRequest.header)
  return header_;
}
inline void SetOutputRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.SetOutputRequest.header)
}

// .contract.Response response = 2;
inline bool SetOutputRequest::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline void SetOutputRequest::clear_response() {
  if (GetArenaNoVirtual() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::contract::Response& SetOutputRequest::response() const {
  const ::contract::Response* p = response_;
  // @@protoc_insertion_point(field_get:contract.SetOutputRequest.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::Response*>(
      &::contract::_Response_default_instance_);
}
inline ::contract::Response* SetOutputRequest::release_response() {
  // @@protoc_insertion_point(field_release:contract.SetOutputRequest.response)
  
  ::contract::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::contract::Response* SetOutputRequest::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.SetOutputRequest.response)
  return response_;
}
inline void SetOutputRequest::set_allocated_response(::contract::Response* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:contract.SetOutputRequest.response)
}

// -------------------------------------------------------------------

// SetOutputResponse

// -------------------------------------------------------------------

// GetCallArgsRequest

// .contract.SyscallHeader header = 1;
inline bool GetCallArgsRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetCallArgsRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::contract::SyscallHeader& GetCallArgsRequest::header() const {
  const ::contract::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:contract.GetCallArgsRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::contract::SyscallHeader*>(
      &::contract::_SyscallHeader_default_instance_);
}
inline ::contract::SyscallHeader* GetCallArgsRequest::release_header() {
  // @@protoc_insertion_point(field_release:contract.GetCallArgsRequest.header)
  
  ::contract::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::contract::SyscallHeader* GetCallArgsRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:contract.GetCallArgsRequest.header)
  return header_;
}
inline void GetCallArgsRequest::set_allocated_header(::contract::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:contract.GetCallArgsRequest.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace contract

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_contract_2eproto
